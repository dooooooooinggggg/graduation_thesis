\chapter{アプローチ}
\label{chap:approach}

\ref{section:purpose}で，本研究の目的を，
動作中のコンピュータのメモリのダンプをリアルタイムで解析することで，コンピュータの状態をリモートホストから知ることができるようにする，と定義した．

そこで本章では，メモリのダンプをリアルタイムで取得．解析する上で前提となる情報と，この手法における課題について述べる．

        \section{オペレーティングシステムのコンテキスト}
\label{section:context}

コンピュータの状態，すなわちオペレーティングシステムの動作中におけるホストの状態は，コンピュータ内部におけるレジスタの値および，内部から参照できる仮想アドレス空間上に保持されている．
その例を下に示す．

あるプロセスを実行する際に，プロセッサはインストラクションポインタレジスタの命令を読み込み，逐次実行をしていく．
call命令などで別の関数を呼ぶ際には，その時点におけるインストラクションポインタレジスタの値をメモリ上に退避し，関数が終わった際に，呼び出し元に返るように設定されている．
実行コードが整合性を保っているかは，実行可能ファイルを生成したコンパイラの責務なので，本論文では述べないが，
プロセッサはプログラムの実行を行う際，レジスタの値を参照，退避，復帰，上書きさせることで，状態を保持，進行させていると言える．

プロセッサがレジスタの値を参照しそれを仕組みは，カーネルのコードを実行する際にも言える．
ここでは，オペレーティングシステムから見たコンピュータの状態として，プロセスの切り替え処理，コンテキストスイッチにおける処理の流れを述べる．
コンテキストスイッチとは，割り込み処理などによって定期的に呼ばれるプロセススケジューラーから呼ばれる機構である．
この機構は，実行中のプロセスの状態，すなわち，各レジスタの値および仮想アドレス空間に関する情報などをカーネルが管理しているメモリ上にあるデータ構造の中に退避する．

本セクションのまとめとして，コンピュータの状態は，ある瞬間においてはレジスタの値であり，この状態を保存する際は，メモリ上にレジスタの値を退避させていることを述べた．

\section{ホスト自身によるレジスタやシンボルの参照}

\ref{section:context}で述べたように，オペレーティングシステムでは，レジスタの値などを退避する際，そのプロセッサ自身が'push'命令などを用いてメモリにアクセスできる

レジスタを参照して，かつmmuすら自分で参照ができるため

\section{オペレーティングシステムのビルドにおけるコンフィグ}

task_struct構造体から辿れる退避されたメンバから値を取り出すことでプロセス空間および状態の復元を行なっている．

task_struct構造体をはじめとして，Linuxカーネルの変数や型，関数は，様々なアーキテクチャやカーネルコンフィグに対応するため，マクロによって分岐されている．
この分岐が確定するのは，Linuxカーネルをビルドするときであり，構造体のメンバへのアクセス，関数のアドレスなどはコンパイラが保証している．

実際のカーネルのバイナリは，vmlinuxとしてコンパイルされた後，stripされbzImageとなる．
ユーザーが作成したカーネルモジュールなどで関数を呼び出す際は，シンボルとアドレスの変換表である`/boot/System.map`を参照し，実際の

CPUレジスタの現在の値は直接知ることができないため，例えばプロセスの一覧を取得したい場合は，コンテキストスイッチ時に退避された値を辿っていく必要がある．
しかし，上述の通りtask_structはビルドされた際のカーネルコンフィグによって，どのメンバが先頭アドレスからどのオフセットに保持されているかは変動する．
