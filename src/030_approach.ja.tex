\chapter{アプローチ}
\label{chap:approach}

\ref{section:purpose}で，本研究の目的を，
動作中のコンピュータのメモリのダンプをリアルタイムで解析することで，コンピュータの状態をリモートホストから知ることができるようにする，と定義した．

\section{オペレーティングシステムのコンテキスト}

コンピュータの状態，すなわちオペレーティングシステムの動作中におけるホストの状態は，コンピュータ内部におけるレジスタの値および，内部から参照できる仮想アドレス空間上に保持されている．
その例をいかに示す．

あるプロセスを実行する際に，プロセッサはインストラクションポインタレジスタの命令を読み込み，逐次実行をしていく．
call命令などで別の関数を呼ぶ際には，その時点におけるインストラクションポインタレジスタの値をメモリ上に退避し，関数が終わった際に，呼び出し元に返るように設定されている．
実行コードが整合性を保っているかは，実行可能ファイルを生成したコンパイラの責務なので，本論文では述べないが，
プロセッサはプログラムの実行を行う際，レジスタの値を参照，退避，復帰，上書きさせることで，状態を保持，進行させていると言える．

この，プロセッサがレジスタの値を参照しそれを仕組みは，カーネルのコードを実行する際にも言える．
オペレーティングシステムから見たコンピュータの状態として，プロセスの切り替え処理，コンテキストスイッチにおける処理の流れを述べる．
プロセスの切り替えを行うコンテキストスイッチでは，task_struct構造体から辿れる退避されたメンバから値を取り出すことでプロセス空間および状態の復元を行なっている．

task_struct構造体をはじめとして，Linuxカーネルの変数や型，関数は，様々なアーキテクチャやカーネルコンフィグに対応するため，マクロによって分岐されている．
この分岐が確定するのは，Linuxカーネルをビルドするときであり，構造体のメンバへのアクセス，関数のアドレスなどはコンパイラが保証している．

実際のカーネルのバイナリは，vmlinuxとしてコンパイルされた後，stripされbzImageとなる．
ユーザーが作成したカーネルモジュールなどで関数を呼び出す際は，シンボルとアドレスの変換表である`/boot/System.map`を参照し，実際の

CPUレジスタの現在の値は直接知ることができないため，例えばプロセスの一覧を取得したい場合は，コンテキストスイッチ時に退避された値を辿っていく必要がある．
しかし，上述の通りtask_structはビルドされた際のカーネルコンフィグによって，どのメンバが先頭アドレスからどのオフセットに保持されているかは変動する．
