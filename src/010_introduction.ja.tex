\chapter{序論}
\label{chap:introduction}

\section{背景}
\label{section:background}

% コンピュータのコンテキストを外部から推測・解析する手法として，メモリフォレンジックがある．
% メモリフォレンジックとは，ある段階におけるメモリのダンプを静的なファイルとして取得し，これを解析していくことで，インシデントレスポンスを行うための手段である．

% メモリフォレンジックを行う際，その経路は複数ある．

% 一つ目はカーネルパニックを起こしたマシンに対するメモリフォレンジックである．
% Linuxカーネルでは，適切に設定をすることで，カーネルパニック発生時に，kdumpと呼ばれる機構を通してメモリの情報を静的ファイルに書き出すことができる．
% このファイルを解析することで，コンピュータがなぜカーネルパニックを発生させたか，などのコンテキストを後から解析することができる．
% kdumpを用いたdumpの書き出しでは，全てのコアが停止した後に，最後にメモリの内容を書き出すため，アトミックな状態のメモリダンプを取得することができる．

% 二つ目は，マルウェアなどの動作を解析するため，動作中のマシンに対してメモリフォレンジックを行う場合である．
% この場合では，動いているホスト内のプロセスとしてメモリの内容をストレージに出力する方法と，VMとして起動し，全てのCPUの

% この書き方だとRDMAに結びつかないし厳密じゃないのでやめた！！

コンピュータの管理者は，動作中のコンピュータの情報を監視することが必要となる場面がある．
例えばtopコマンドやpsコマンドを用いて，プロセスの一覧を得たり，gdbコマンドを用いてプロセスをトレースし，プロセスの状態を把握する．

その他にも，様々な手段を用いてログイン中のそのコンピュータ自身の状態を監視・解析する．

\section{着目する課題}

コンピュータの状態は，コンピュータ内部におけるレジスタの値および，内部から参照できる仮想アドレス空間上に保持されている．

例えばコンテキストスイッチでは，task_struct構造体から辿れる退避されたメンバから値を取り出すことでプロセス空間および状態の復元を行なっている．

task_struct構造体をはじめとして，Linuxカーネルの変数や型，関数は，様々なアーキテクチャやカーネルコンフィグに対応するため，マクロによって分岐されている．
この分岐が確定するのは，Linuxカーネルをビルドするときであり，構造体のメンバへのアクセス，関数のアドレスなどはコンパイラが保証している．

実際のカーネルのバイナリは，vmlinuxとしてコンパイルされた後，stripされbzImageとなる．
ユーザーが作成したカーネルモジュールなどで関数を呼び出す際は，シンボルとアドレスの変換表である`/boot/System.map`を参照し，実際の

背景で述べたRDMA NICを用いた解析手法では，メモリの物理アドレスを指定し，逐次的に値を取得し外部から復元していくが，
CPUレジスタの現在の値は直接知ることができないため，例えばプロセスの一覧を取得したい場合は，コンテキストスイッチ時に退避された値を辿っていく必要がある．
しかし，上述の通りtask_structはビルドされた際のカーネルコンフィグによって，どのメンバが先頭アドレスからどのオフセットに保持されているかは変動する．

Linuxカーネルのバージョン，System.mapの情報およびconfigの情報を知らなければ，メモリのみから正しくコンテキストを復元していくことはできない．

本研究では，上記3つの情報のうち，System.mapおよびビルド時のカーネルコンフィグの値を知ることができないことを問題と定義する．

\section{目的}

以上の背景および課題から，

\section{アプローチ}

アプローチ

\section{構成}

構成
